:py:mod:`box_embeddings.modules.volume.tf_bessel_volume`
========================================================

.. py:module:: box_embeddings.modules.volume.tf_bessel_volume


Module Contents
---------------

.. py:data:: eps
   :annotation: = 1e-23

   

.. py:data:: euler_gamma
   :annotation: = 0.5772156649015329

   

.. py:function:: tf_bessel_volume_approx(box_tensor: box_embeddings.parameterizations.tf_box_tensor.TFBoxTensor, beta: float = 1.0, gumbel_beta: float = 1.0, scale: float = 1.0) -> tensorflow.Tensor

   Volume of boxes. Uses the Softplus as an approximation of
   Bessel funtion.

   :param box_tensor: input
   :param beta: the beta parameter for the softplus.
   :param gumbel_beta: the gumbel_beta parameter (same value used in intersection).
   :param scale: scale parameter. Should be left as 1.0 (default)
                 in most cases.

   :returns: Tensor of shape (..., ) when self has shape (..., 2, num_dims)

   :raises ValueError: if scale not in (0,1]


.. py:function:: tf_log_bessel_volume_approx(box_tensor: box_embeddings.parameterizations.tf_box_tensor.TFBoxTensor, beta: float = 1.0, gumbel_beta: float = 1.0, scale: float = 1.0) -> tensorflow.Tensor

   Volume of boxes. Uses the Softplus as an approximation of
   Bessel funtion.

   :param box_tensor: input.
   :param beta: the beta parameter for the softplus.
   :param gumbel_beta: the gumbel_beta parameter (same value used in intersection).
   :param scale: scale parameter. Should be left as 1.0 (default)
                 in most cases.

   :returns: Tensor of shape (..., ) when self has shape (..., 2, num_dims)

   :raises ValueError: if scale not in (0,1]


.. py:class:: TFBesselApproxVolume(log_scale: bool = True, beta: float = 1.0, gumbel_beta: float = 1.0)

   Bases: :py:obj:`box_embeddings.modules.volume.tf_volume.TFVolume`

   Uses the Softplus as an approximation of
   Bessel function.

   .. py:attribute:: default_implementation
      :annotation: = hard

      

   .. py:method:: forward(self, box_tensor: box_embeddings.parameterizations.tf_box_tensor.TFBoxTensor) -> tensorflow.Tensor
      :abstractmethod:

      Base implementation is hard (ReLU) volume.

      :param box_tensor: Input box tensor

      :raises NotImplementedError: base class


   .. py:method:: name(self)
      :property:

      Returns the name of this module as passed or determined in the ctor.

      NOTE: This is not the same as the `self.name_scope.name` which includes
      parent module names.


   .. py:method:: name_scope(self)
      :property:

      Returns a `tf.name_scope` instance for this class.


   .. py:method:: variables(self)
      :property:

      Sequence of variables owned by this module and its submodules.

      Note: this method uses reflection to find variables on the current instance
      and submodules. For performance reasons you may wish to cache the result
      of calling this method if you don't expect the return value to change.

      :returns: A sequence of variables for the current module (sorted by attribute
                name) followed by variables from all submodules recursively (breadth
                first).


   .. py:method:: trainable_variables(self)
      :property:

      Sequence of trainable variables owned by this module and its submodules.

      Note: this method uses reflection to find variables on the current instance
      and submodules. For performance reasons you may wish to cache the result
      of calling this method if you don't expect the return value to change.

      :returns: A sequence of variables for the current module (sorted by attribute
                name) followed by variables from all submodules recursively (breadth
                first).


   .. py:method:: non_trainable_variables(self)
      :property:

      Sequence of non-trainable variables owned by this module and its submodules.

      Note: this method uses reflection to find variables on the current instance
      and submodules. For performance reasons you may wish to cache the result
      of calling this method if you don't expect the return value to change.

      :returns: A sequence of variables for the current module (sorted by attribute
                name) followed by variables from all submodules recursively (breadth
                first).


   .. py:method:: submodules(self)
      :property:

      Sequence of all sub-modules.

      Submodules are modules which are properties of this module, or found as
      properties of modules which are properties of this module (and so on).

      >>> a = tf.Module()
      >>> b = tf.Module()
      >>> c = tf.Module()
      >>> a.b = b
      >>> b.c = c
      >>> list(a.submodules) == [b, c]
      True
      >>> list(b.submodules) == [c]
      True
      >>> list(c.submodules) == []
      True

      :returns: A sequence of all submodules.


   .. py:method:: with_name_scope(cls, method)
      :classmethod:

      Decorator to automatically enter the module name scope.

      >>> class MyModule(tf.Module):
      ...   @tf.Module.with_name_scope
      ...   def __call__(self, x):
      ...     if not hasattr(self, 'w'):
      ...       self.w = tf.Variable(tf.random.normal([x.shape[1], 3]))
      ...     return tf.matmul(x, self.w)

      Using the above module would produce `tf.Variable`s and `tf.Tensor`s whose
      names included the module name:

      >>> mod = MyModule()
      >>> mod(tf.ones([1, 2]))
      <tf.Tensor: shape=(1, 3), dtype=float32, numpy=..., dtype=float32)>
      >>> mod.w
      <tf.Variable 'my_module/Variable:0' shape=(2, 3) dtype=float32,
      numpy=..., dtype=float32)>

      :param method: The method to wrap.

      :returns: The original method wrapped such that it enters the module's name scope.


   .. py:method:: register(cls: Type[T], name: str, constructor: str = None, exist_ok: bool = False) -> Callable[[Type[T]], Type[T]]
      :classmethod:

      Transparent method

      :param name: TODO
      :param constructor: TODO
      :param exist_ok: TODO

      :returns: a wrapped callable



